<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Connections TR</title>
  <style>
    :root{
      --bg:#ffffff; --text:#151515;
      --tile:#f1f1ed; --tileSel:#cfcfca; --border:#b5b5ae; --black:#111111;
      --yellow:#f4de73; --green:#a8c26f; --blue:#b2c7ee; --purple:#b189c8;
      --gap:18px; --tileH:78px; --barH:86px;
      --radius:14px;
      --ease:cubic-bezier(.2,.8,.2,1);
    }
    *{box-sizing:border-box; font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    body{margin:0; background:var(--bg); color:var(--text);}
    .wrap{width:min(880px, calc(100vw - 24px)); margin:18px auto;}
    .title{font-size:20px; text-align:center; margin: 6px 0 2px;}
    .msg{font-size:22px; font-weight:900; text-align:center; height:30px; margin: 8px 0 10px;}

    .bars{display:flex; flex-direction:column; gap:14px; margin: 8px 0 16px;}
    .bar{
      height:var(--barH); border-radius:var(--radius);
      display:none; align-items:center; justify-content:center; flex-direction:column;
    }
    .barTitle{font-weight:900; font-size:22px; line-height:1.05; margin-top:8px;}
    .barWords{font-size:18px; line-height:1.1; margin-bottom:10px;}

    .grid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: var(--gap);
      margin-bottom: 14px;
    }
    .tile{
      height:var(--tileH);
      border-radius:var(--radius);
      background:var(--tile);
      border:2px solid var(--border);
      display:flex; align-items:center; justify-content:center;
      font-weight:900; font-size:18px;
      cursor:pointer; user-select:none;
      transition: background .12s ease, border-color .12s ease;
    }
    .tile.selected{ background:var(--tileSel); border:4px solid var(--tileSel); }
    .tile.locked:not(.floating){ display:none; }

    .mist{ text-align:center; margin: 6px 0 10px; font-size:14px; color:#404040;}
    .dots{display:flex; justify-content:center; gap:10px; margin-top:6px;}
    .dot{font-size:22px; line-height:22px; color:#000;}
    .dot.off{color:#e0e0e0;}

    .btnrow{display:flex; justify-content:center; gap:26px; margin-top: 10px; flex-wrap:wrap;}
    .btn{
      width:190px; height:56px; border-radius:18px;
      border:2px solid var(--black); background:#fff;
      font-weight:900; font-size:16px; cursor:pointer;
    }
    .btn:active{background:#f0f0f0}
    .btn:disabled{opacity:.5; cursor:not-allowed}

    /* Ghost layer */
    .ghostLayer{position:relative; height:0;}
    .ghost{
      position:absolute;
      width: calc((min(880px, calc(100vw - 24px)) - 3*var(--gap))/4);
      height: var(--tileH);
      border-radius: var(--radius);
      background: var(--tileSel);
      border:4px solid var(--tileSel);
      display:flex; align-items:center; justify-content:center;
      font-weight:900; font-size:18px;
      transform: translate(0,0);
      transition: transform 520ms var(--ease);
      pointer-events:none;
    }

    /* Mobile tweak */
    @media (max-width: 560px){
      .grid{grid-template-columns: repeat(2, 1fr);}
      .ghost{width: calc((min(880px, calc(100vw - 24px)) - 1*var(--gap))/2);}
    }
    /* Flying selected tiles (real tiles, not ghosts) */
  .floating{
    position: fixed !important;
    z-index: 9999;
    margin: 0 !important;
    transition: transform 520ms cubic-bezier(.2,.8,.2,1);
  }

  .flip{
    transition: transform 260ms cubic-bezier(.2,.8,.2,1);
    will-change: transform;
  }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="title">Create four groups of four!</div>
    <div id="msg" class="msg"></div>

    <div id="bars" class="bars"></div>

    <div id="grid" class="grid"></div>

    <div class="mist">Mistakes Remaining:
      <div class="dots" id="dots"></div>
    </div>

    <div class="btnrow">
      <button class="btn" id="shuffle">Shuffle</button>
      <button class="btn" id="submit">Submit</button>
      <button class="btn" id="clear">Deselect All</button>
    </div>

    <div class="ghostLayer" id="ghostLayer"></div>
  </div>

<script>
(() => {
  // ---------- Puzzle (ÅŸimdilik hard-coded) ----------
  const COLORS = {
    yellow: getCss('--yellow'), green: getCss('--green'),
    blue: getCss('--blue'), purple: getCss('--purple')
  };

  const puzzle = {
    words: ["GÃ–Z","EL","DÄ°L","YÃœZ","MANTI","BÃ–REK","PÄ°DE","LAHMACUN","YAZ","YAZAR","YAZI","YAZMAK","KAR","KOR","KIL","KAL"],
    groups: [
      {label:"VÃœCUT/ORGAN", items:["GÃ–Z","EL","DÄ°L","YÃœZ"], color: COLORS.yellow},
      {label:"HAMUR Ä°ÅžÄ°",   items:["MANTI","BÃ–REK","PÄ°DE","LAHMACUN"], color: COLORS.green},
      {label:"YAZ- KÃ–KÃœ",   items:["YAZ","YAZAR","YAZI","YAZMAK"], color: COLORS.blue},
      {label:"K_ R / K_ L", items:["KAR","KOR","KIL","KAL"], color: COLORS.purple},
    ]
  };

  // ---------- State ----------
  let mistakesLeft = 4;
  let selected = new Set();      // Set<HTMLElement tile>
  let found = [false,false,false,false];
  let barSlot = 0;
  let animating = false;

  const msgEl = el('#msg');
  const gridEl = el('#grid');
  const barsEl = el('#bars');
  const dotsEl = el('#dots');
  const ghostLayer = el('#ghostLayer');

  const btnShuffle = el('#shuffle');
  const btnSubmit  = el('#submit');
  const btnClear   = el('#clear');

  // ---------- Init ----------
  renderBars();
  renderDots();
  renderGrid(shuffle([...puzzle.words]));

  btnShuffle.onclick = () => !animating && shuffleOpen();
  btnClear.onclick   = () => !animating && clearSelection();
  btnSubmit.onclick  = () => !animating && submit();

  // ---------- Rendering ----------
  function renderBars(){
    barsEl.innerHTML = "";
    for(let i=0;i<4;i++){
      const b = document.createElement('div');
      b.className = "bar";
      b.id = `bar-${i}`;
      b.innerHTML = `<div class="barTitle"></div><div class="barWords"></div>`;
      barsEl.appendChild(b);
    }
  }

  function renderDots(){
    dotsEl.innerHTML = "";
    for(let i=0;i<4;i++){
      const d = document.createElement('div');
      d.className = "dot" + (i < mistakesLeft ? "" : " off");
      d.textContent = "â—";
      dotsEl.appendChild(d);
    }
  }

  function renderGrid(words){
    gridEl.innerHTML = "";
    words.forEach((w) => {
      const t = document.createElement('div');
      t.className = "tile";
      t.dataset.word = w;
      t.textContent = w;
      t.onclick = () => {
        if(animating) return;
        if(t.classList.contains('locked')) return;
        if(selected.has(t)){
          selected.delete(t);
          t.classList.remove('selected');
        }else{
          if(selected.size >= 4){ setMsg("En fazla 4 kelime seÃ§ebilirsin."); return; }
          selected.add(t);
          t.classList.add('selected');
        }
      };
      gridEl.appendChild(t);
    });
  }

  // ---------- Actions ----------
  function setMsg(t){ msgEl.textContent = t || ""; }

  function clearSelection(){
    selected.forEach(t => t.classList.remove('selected'));
    selected.clear();
    setMsg("");
  }

  function shuffleOpen(){
    const open = getOpenTiles();
    const ws = open.map(t => t.dataset.word);
    shuffle(ws);
    open.forEach((t,i)=>{ t.dataset.word = ws[i]; t.textContent = ws[i]; t.classList.remove('selected'); });
    selected.clear();
    setMsg("Shuffled");
  }

  function submit(){
    if(selected.size !== 4){ setMsg("4 kelime seÃ§."); return; }

    const selWords = [...selected].map(t => t.dataset.word).sort();
    let hit = -1;
    for(let i=0;i<puzzle.groups.length;i++){
      if(found[i]) continue;
      const target = puzzle.groups[i].items.map(x=>x.toUpperCase()).sort();
      if(arrEq(selWords, target)){ hit = i; break; }
    }

    if(hit === -1){
      mistakesLeft -= 1;
      renderDots();
      setMsg("Tekrar dene.");
      if(mistakesLeft <= 0){
        setMsg("Bitti.");
        disableAll();
      }
      return;
    }

    setMsg("DoÄŸru!");
    animateSolve(hit, puzzle.groups[hit]);
  }

  function disableAll(){
    btnShuffle.disabled = true;
    btnSubmit.disabled  = true;
    btnClear.disabled   = true;
    getAllTiles().forEach(t => t.style.pointerEvents = "none");
  }

  // ---------- NYT-style animation ----------
async function animateSolve(groupIndex, groupDef){
  animating = true;

  const bar = el(`#bar-${barSlot}`);

  // ---------- FIRST: Ã¶lÃ§ (griddeyken) ----------
  const allTiles = getAllTiles(); // locked olmayanlar + selected dahil
  const first = new Map();
  allTiles.forEach(t => first.set(t, rect(t)));

  // seÃ§ilenleri soldan saÄŸa sÄ±rala
  const selTiles = [...selected].sort((a,b)=> rect(a).left - rect(b).left);

  // ---------- 1) Bar placeholder aÃ§: grid aÅŸaÄŸÄ± insin ----------
  bar.style.display = "flex";
  bar.style.background = "#ffffff";
  bar.querySelector('.barTitle').textContent = "";
  bar.querySelector('.barWords').textContent = "";

  await nextFrame(); // bar gÃ¶rÃ¼nÃ¼r -> layout deÄŸiÅŸsin

  // ---------- 2) SeÃ§ili tile'larÄ± "uÃ§an" moda al (KAYBOLMADAN) ----------
  // Sabitle: mevcut ekrandaki pozisyonlarÄ±nÄ± fixed'e Ã§evir
  const selFixedStart = selTiles.map(t => {
    const r = rect(t);
    t.classList.add('floating');        // fixed olur
    t.style.left = r.left + "px";
    t.style.top  = r.top  + "px";
    t.style.width  = r.width + "px";
    t.style.height = r.height + "px";
    t.style.transform = "translate(0px,0px)";
    return r;
  });

  // ---------- 3) Grid reflow: seÃ§ili tile'larÄ±n yerini boÅŸalt ----------
  // (gridde boÅŸluk kalmasÄ±n diye gridden Ã§Ä±karÄ±yoruz ama kendileri fixed olduÄŸu iÃ§in gÃ¶rÃ¼nmeye devam edecek)
  selTiles.forEach(t => t.classList.add('locked'));
  // artÄ±k selected set temizleyelim
  selected.clear();

  // ---------- LAST: reflow sonrasÄ± Ã¶lÃ§ ----------
  await nextFrame(); // reflow gerÃ§ekleÅŸsin
  const remaining = getOpenTiles(); // locked olmayanlar
  const last = new Map();
  remaining.forEach(t => last.set(t, rect(t)));

  // ---------- INVERT + PLAY (FLIP): kalan tile'lar smooth hareket etsin ----------
  remaining.forEach(t => {
    const a = first.get(t);
    const b = last.get(t);
    if(!a || !b) return;
    const dx = a.left - b.left;
    const dy = a.top  - b.top;
    t.classList.add('flip');
    t.style.transform = `translate(${dx}px, ${dy}px)`;
  });

  // transformâ€™u 1 frame sonra sÄ±fÄ±rla -> animasyon baÅŸlar
  await nextFrame();
  remaining.forEach(t => { t.style.transform = "translate(0px,0px)"; });

  // ---------- 4) SeÃ§ili tile'larÄ± bar iÃ§ine uÃ§ur (no scale) ----------
  const br = rect(bar);
  const gw = selFixedStart[0].width;
  const gh = selFixedStart[0].height;
  const gap = parseFloat(getCss('--gap')) || 18;

  const totalW = 4*gw + 3*gap;
  const startX = br.left + (br.width - totalW)/2;
  const y = br.top + (br.height - gh)/2;

  selTiles.forEach((t,i)=>{
    const r0 = selFixedStart[i];
    const tx = (startX + i*(gw+gap)) - r0.left;
    const ty = y - r0.top;
    requestAnimationFrame(()=> {
      t.style.transform = `translate(${tx}px, ${ty}px)`;
    });
  });

  // uÃ§uÅŸ bitsin
  await sleep(560);

  // ---------- 5) SeÃ§ili tile'larÄ± tamamen kaldÄ±r + barÄ± finalize et ----------
  selTiles.forEach(t => t.remove());

  bar.style.background = groupDef.color;
  bar.querySelector('.barTitle').textContent = groupDef.label.toUpperCase();
  bar.querySelector('.barWords').textContent = groupDef.items.map(x=>x.toUpperCase()).join(", ");

  found[groupIndex] = true;
  barSlot += 1;

  // cleanup: flip classâ€™larÄ± bir sÃ¼re sonra temizle (istersen kalsÄ±n da olur)
  setTimeout(()=>{
    remaining.forEach(t => t.classList.remove('flip'));
  }, 300);

  animating = false;

  if(found.every(Boolean)){
    setMsg("Hepsi tamam! ðŸŽ‰");
    disableAll();
  }
}

  function createGhostFromTile(tile){
    const g = document.createElement('div');
    g.className = "ghost";
    g.textContent = tile.dataset.word;

    const tr = rect(tile);
    const wr = rect(document.querySelector('.wrap'));

    g.style.left = (tr.left - wr.left) + "px";
    g.style.top  = (tr.top  - wr.top ) + "px";

    ghostLayer.appendChild(g);
    return g;
  }

  function moveGhostsToBar(ghosts, bar){
    const br = rect(bar);
    const wr = rect(document.querySelector('.wrap'));

    // Ghost size (same as tiles)
    const gw = rect(ghosts[0]).width;
    const gh = rect(ghosts[0]).height;
    const gap = parseFloat(getCss('--gap')) || 18;

    // Targets: 4 across inside bar
    const totalW = 4*gw + 3*gap;
    const startX = (br.left - wr.left) + (br.width - totalW)/2;
    const y = (br.top - wr.top) + (br.height - gh)/2;

    ghosts.forEach((g,i)=>{
      const x0 = parseFloat(g.style.left);
      const y0 = parseFloat(g.style.top);
      const dx = (startX + i*(gw+gap)) - x0;
      const dy = (y) - y0;
      requestAnimationFrame(()=>{ g.style.transform = `translate(${dx}px, ${dy}px)`; });
    });
  }

  // ---------- Utilities ----------
  function el(q){ return document.querySelector(q); }
  function getAllTiles(){ return [...gridEl.querySelectorAll('.tile')]; }
  function getOpenTiles(){ return getAllTiles().filter(t => !t.classList.contains('locked')); }
  function rect(node){ return node.getBoundingClientRect(); }
  function arrEq(a,b){ return a.length===b.length && a.every((v,i)=>v===b[i]); }

  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  function getCss(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
  function nextFrame(){ return new Promise(r => requestAnimationFrame(()=>r())); }
})();
</script>
</body>
</html>
